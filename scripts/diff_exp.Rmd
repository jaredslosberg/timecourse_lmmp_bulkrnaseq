---
title: "aged timecourse bulkRNA-seq "
output: html_document
---


```{r, include= F}
library(tidyverse)
library(glue)
library(DESeq2)
library(here)
library(tximport)
library(RColorBrewer)
library(vsn)
library(ComplexHeatmap)
library(biomaRt)
```

Read in experimental metadata
```{r}
data_dir <- here("kallisto_out/")
metadata_path <- here("metadata.csv")
list.files(data_dir)


exp_metadata <- read.csv(metadata_path, header = T)

abundance_filepath <- paste0(data_dir, exp_metadata[,"sample_name"], "/abundance.tsv")
names(abundance_filepath) <- exp_metadata[, "sample_name"]
file.exists(abundance_filepath)

# named_runs <- exp_metadata %>% deframe
```

Read in gene abundance matrices for each run
```{r}
txdb <- GenomicFeatures::makeTxDbFromGFF("/reference/genomes/mouse/gencode/vM27/gencode.vM27.annotation.gff3.gz")
k <- keys(txdb, keytype = "TXNAME" )
tx2gene <- select(txdb, k, "GENEID", "TXNAME")

#There is an issue with how kallisto writes its .h5 files (https://support.bioconductor.org/p/130419/)
#So use tsv, and dropInfReps=T to avoid anything related to the .h5 file
txi <- tximport(abundance_filepath, type = "kallisto", txOut = F, tx2gene = tx2gene, ignoreAfterBar = T, dropInfReps = T, countsFromAbundance = "scaledTPM")

write.csv(txi$counts, here("data/abundance_to_counts_matrix.csv"), quote = F)
```

Check transformations from abundance to counts
```{r}
#output from kallisto quantification
txi$abundance %>% head

txi$counts %>% head

#qplot(log2(txi$abundance), log2(txi$counts), color = txi$length) + scale_color_gradient(name = "tx length", trans = "log2",breaks = c(500, 10000, 30000, 60000, 120000), labels = c(500, 10000, 30000, 60000, 120000))
```




Get biomart annotations for gene short names
```{r}
library(biomaRt)
#get gene names, make sure to use the right ensembl archive for genome used for alignment
#listMarts() 
ensembl <- useMart("ensembl")
datasets <- listDatasets(ensembl)
ensembl <- useDataset("mmusculus_gene_ensembl",mart=ensembl)

gene_id_trimmed <- stringr::str_split_fixed(unique(tx2gene[,"GENEID"]),"\\.",2)[,1]
gene_description <- getBM(attributes = c("ensembl_gene_id_version","external_gene_name","description","chromosome_name"),
                   filters = "ensembl_gene_id", values =gene_id_trimmed,  mart = ensembl)

geneid2name <- gene_description[,c("ensembl_gene_id_version", "external_gene_name")] %>% 
  mutate(ensembl_gene_id_trimmed = str_split_fixed(ensembl_gene_id_version, "\\.", 2) %>% .[,1])

```

Following DESEQ tutorial @ [here](http://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)

Prep data frame with sample <<-->> group info
```{r}
# #experimental design
# cond <- colnames(txi$abundance)
# 
# coldata <- data.frame("condition" = colnames(total_counts)) %>%
#   mutate(condition = case_when(
#     grepl("HF_", condition) ~ "HF",
#     grepl("NF_", condition) ~ "NF",
#     grepl("NF-sugar_", condition) ~ "NF-sugar",
#     grepl("HF-sugar_", condition) ~ "HF-sugar") %>%
#       as.factor()
#   ) 

coldata <- exp_metadata %>% tibble::column_to_rownames(var = "sample_name")

assertthat::assert_that(all(rownames(coldata) == colnames(txi$abundance)))

coldata 
#Batches or which tissues are from the same animal are unknown



```
Create DeSeq object with counts and exp design. Don't include batch at first
```{r}

dds <- DESeqDataSetFromTximport(txi,
                              colData = coldata,
                              design = ~ age)

dds$age <- factor(dds$age, levels = c("P30","6mo","17mo"), ordered = F)

# #Add gene short names to object
# gene_short_name <- data.frame(rownames(total_counts))
# mcols(dds) <- DataFrame(mcols(dds), gene_short_name)

#Filter out genes with a sum of all abundances across samples of less than 10
keep <- rowSums(counts(dds)) >= 10
genes_keep <- names(keep[keep])
dds <- dds[keep,]

agg <- counts(dds) %>% as.matrix() %>% Matrix::colSums()
barplot(unname(agg), horiz = T, ylab = "samples", xlab = "number of reads")


# dds$condition <- factor(dds$condition, levels = c("GF","OMM","SPF","OMMMC2D2","OMMMC2D4","OMMMC2D6","OMMMC2D8"))

dds

#Number of counts per sample are different, shouldn't this be normalized?
assay(dds, "counts") %>% Matrix::colSums()
```

Diff expression with default parameters (maybe revisit)
I don't have replicates, and I didn't think this would work without them. Is it treating 20wk-untreated and 20wk-treated as replicates for 20wk?
```{r}
dds <- DESeq(dds)
res <- results(dds)
res
```

```{r}
rownames(dds) <- rownames(dds) %>% str_split_fixed(., "\\.", 2) %>% .[,1]
genes_keep_trimmed <- genes_keep %>% str_split_fixed(., "\\.", 2) %>% .[,1]

geneid2name <- geneid2name %>% tibble::column_to_rownames(var = "ensembl_gene_id_trimmed")

dup_ind <- geneid2name[genes_keep_trimmed,"external_gene_name"] %>% duplicated() %>% which
dup_genes_sn <- geneid2name[genes_keep_trimmed, "external_gene_name"] %>% .[dup_ind]
dup_genes <- rownames(geneid2name)[dup_ind]

saveRDS(dds, here("data/bulkrna_dds.rds"))
```

Return results for a specific sample comparison
```{r}
res <- results(dds, contrast=c(c("age", "17mo",  "P30")))
res %>% head
summary(res)

```
comparing 17month to 30 day, 14% of genes are upregulated & 9% of genes are downreg


```{r}
resultsNames(dds)
resLFC <- lfcShrink(dds,coef = "age_17mo_vs_P30", type="apeglm")
resLFC %>% class


```

```{r}

plotMA(res, ylim=c(-2,2), main = res@elementMetadata@listData$description[2])

plotMA(resLFC, ylim=c(-2,2), main = res@elementMetadata@listData$description[2])

```

```{r}

# this gives log2(n + 1)
ntd <- normTransform(dds)
library("vsn")

rld <- rlog(dds, blind=FALSE)

vsd <- vst(dds, blind=FALSE)
#rld <- rlog(dds, blind=FALSE)
head(assay(vsd),3)
```

```{r}
meanSdPlot(assay(ntd))
meanSdPlot(assay(vsd))
meanSdPlot(assay(rld))

```

```{r}
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
p <- Heatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_columns=sampleDists,
         col=colors, row_names_gp = gpar(fontsize = 6))

cor_mat <- cor(assay(vsd))
colors <- colorRampPalette(brewer.pal(9, "Reds"))(255)
colnames(cor_mat) <- NULL
p2 <- Heatmap(cor_mat,
         clustering_distance_rows="canberra",
         clustering_distance_columns="canberra",
         col=colors, row_names_gp = gpar(fontsize = 6))


p
p2

# pdf(here(glue("plots/", de_condition, "_similarity_heatmaps.pdf")), height = 12, width = 14)
# p
# p2
# dev.off()
```
This distance-based similarity matrix shows that the replicates are not ideal replcates. HF-sugar/1/2 cluster well together with low distance, but the rest do not seem to group with their condition. For example, HF belongs in a different branch than HF1/2 and HF-sugar/1/2. HF2 is more similar to HF-sugar than HF/1


```{r}
pcaData <- plotPCA(vsd, intgroup=c("age", "sex", "rep", "lane", "cell", "sizeFactor"), returnData = T)
percentVar <- round(100 * attr(pcaData, "percentVar"))


features <- c("age", "sex", "rep", "lane", "cell", "sizeFactor")
map(features, function(feat){
ggplot(pcaData, aes_string("PC1", "PC2", color=feat)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()
})


vsd_sub <- vsd

pcaData_sub <- prcomp(t(assay(vsd_sub)), center = T, scale = F)
var_df <- data.frame(stdev = pcaData_sub$sdev) %>% mutate(var = stdev^2, percent_var = round(var/sum(var), 3)*100)

assertthat::assert_that(all(rownames(pcaData_sub) == rownames(colData(vsd_sub))))
pcaData_sub <- cbind(pcaData_sub$x, colData(vsd_sub)) %>% as.data.frame()

features <- c("age", "sex", "rep", "lane", "cell", "sizeFactor")
map(features, function(feat){
ggplot(pcaData, aes_string("PC1", "PC2", color=feat)) +
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()
})


# ggplot(pcaData, aes(PC1, PC2, color=condition, shape = batch)) +
#   geom_point(size=3) +
#   xlab(paste0("PC1: ",percentVar[1],"% variance")) +
#   ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
#   coord_fixed()

```


Differential expression on relevant conditions
```{r}
test_names <- resultsNames(dds)[-c(1)]
gene_ids <- geneid2name %>% rownames_to_column(var = "ensemblgene_id") %>% dplyr::select(-c("ensembl_gene_id_version"))

if(!dir.exists(here("results/diff_exp"))) dir.create(here("results/diff_exp"))
map(test_names, function(name){
  comp_res <- results(dds,name = name) %>%
    as.data.frame() %>%
    rownames_to_column(var = "ensemblgene_id") %>%
    left_join(., gene_ids, by= "ensemblgene_id") %>%
    relocate(external_gene_name) %>%
    arrange(desc(log2FoldChange))
  
  write.csv(comp_res, paste0(here("results/diff_exp/"), name,".csv"))
})

```


NMF time, can we find an age-related signature
```{r}
library(NNLM)

set.seed(136)
dimensionalities <- c(10)


nmf_res <- nnmf(assay(vsd), k = dimensionality)

sample_weights <- nmf_res$H 
rownames(sample_weights) <- paste0("pattern", 1:dimensionality)
gene_weights <- nmf_res$W
colnames(gene_weights) <- paste0("pattern", 1:dimensionality)


if(!dir.exists(here("results/NMF", paste0("dim",dimensionality)))){
  dir.create(here("results/NMF", paste0("dim",dimensionality)))
}
write.csv(as.data.frame(gene_weights), here("results/NMF", paste0("dim",dimensionality), "gene_weights.csv"), quote = F)
write.csv(as.data.frame(sample_weights), here("results/NMF", paste0("dim",dimensionality), "sample_weights.csv"), quote = F)

return(list(A = sample_weights, P = gene_weights))
```

Which patterns are more highly/lowly used in each condition? Run a regression with age,treatment,region to discover which variables determine pattern usage
```{r}

dimensionality <- 10

s_weights <- nmf_res[["H"]]
sw_long <- sample_weights %>% 
  as.data.frame() %>%
  rownames_to_column(var = "pattern_no") %>%
  pivot_longer(cols = !pattern_no, names_to = "sample_name", values_to = "pattern_weight") %>%
  left_join(., exp_metadata) %>% mutate(age = factor(age, levels = c("P30","6mo","17mo")))

reg_res_df <- map(rownames(sample_weights), function(patt){

  sw_long_filt <- sw_long %>% filter(pattern_no == patt)
   reg_res <- lm(pattern_weight ~ age, data = sw_long_filt)

   coef(reg_res) %>% as.data.frame() %>% setNames(patt)
 }) %>% bind_cols()

 #order pattern rows
 pattern_dend <- as.dendrogram(hclust(dist(t(as.matrix(reg_res_df)))))
 ggdendro::ggdendrogram(pattern_dend)
 pattern_order <- colnames(reg_res_df)[order.dendrogram(pattern_dend)]

 #order samples columns
 coef_dend <- as.dendrogram(hclust(dist(as.matrix(reg_res_df))))
 ggdendro::ggdendrogram(coef_dend)
 coef_order <- rownames(reg_res_df)[order.dendrogram(coef_dend)]

 reg_res_df_long <- reg_res_df %>% rownames_to_column(var = "coef") %>%
   pivot_longer(!coef, names_to = "pattern_no", values_to = "pattern_weight") %>%
   mutate(coef = factor(coef, levels = coef_order)) %>%
   mutate(pattern_no = factor(pattern_no, levels = pattern_order))


 print(ggplot(reg_res_df_long) + geom_tile(aes(x = coef, y = pattern_no, fill = pattern_weight)) + scale_fill_gradient2(
   low = 'blue', mid = 'white', high = 'red',
   midpoint = 0, guide = 'colourbar', aesthetics = 'fill') +
     ggtitle("regression coefficients: ~age ",
             subtitle = paste0("dimensionality: ",dimensionality," patterns")) +
     theme(axis.text.x = element_text(angle = 90))
 )

 reg_res_df_long




```
Intercept column's meaning is the pattern usage for P30 (when age is reference). Then age6mo and age17mo effects are relative to that. So rows that are blue for those effects are consistently down with age, those that are red are consistently up with age. Pattern 8 is odd in that is lower in 6mo vs P30, but higher in 17mo vs P30.

```{r}

  print(dimensionality)
  
  corr_mat <- map(rownames(sample_weights), function(patt){
    
    sw_long_filt <- sw_long %>% filter(pattern_no == patt)
    
    var_over <- c("age","rep")
    
    corr_vec <- map(var_over, function(meta){
      
      levs <- sw_long_filt[,meta]  %>% unique %>% deframe() %>% as.character()
      map_dbl(levs, function(lev){
        
        sw_long_filt[sw_long_filt[,meta] == lev,"test"] <- 1
        sw_long_filt[sw_long_filt[,meta] != lev,"test"] <- 0
        cor_val <- cor(as.numeric(as.matrix(sw_long_filt[,"pattern_weight"])), as.numeric(as.matrix(sw_long_filt[,"test"])))
      }) %>% setNames(levs)
    }) %>% unlist()
    
  
  }) %>% setNames(rownames(sample_weights)) %>% do.call(rbind,.)
  #through here I have a matrix for one dimensionality
  
  #order pattern rows
  pattern_dend <- as.dendrogram(hclust(dist(as.matrix(corr_mat))))
  ggdendro::ggdendrogram(pattern_dend)
  pattern_order <- rownames(corr_mat)[order.dendrogram(pattern_dend)]
  
  #order samples columns
  coef_dend <- as.dendrogram(hclust(dist(t(as.matrix(corr_mat)))))
  ggdendro::ggdendrogram(coef_dend)
  coef_order <- colnames(corr_mat)[order.dendrogram(coef_dend)]
  
  corr_mat_long <- corr_mat %>% as.data.frame() %>% rownames_to_column(var = "pattern_no") %>%
    pivot_longer(!pattern_no, names_to = "coef", values_to = "correlation") %>%
    mutate(coef = factor(coef, levels = coef_order)) %>%
    mutate(pattern_no = factor(pattern_no, levels = pattern_order))
  
  
  print(ggplot(corr_mat_long) + geom_tile(aes(x = coef, y = pattern_no, fill = correlation)) + scale_fill_gradient2(
      low = 'blue', mid = 'white', high = 'red',
      midpoint = 0, guide = 'colourbar', aesthetics = 'fill', limits = c(-1,1)) +
    ggtitle("Correlation: metadata x pattern usage",
            subtitle = paste0("dimensionality: ",dimensionality," patterns")) +
    theme(axis.text.x = element_text(angle = 90))
  )
  
  
  corr_mat_long


```

GSEA on pattern definition genes
```{r, eval = F}
library(clusterProfiler)
library(org.Mm.eg.db)
library(DOSE)
library(grid)
library(gridExtra)
library(biomaRt)
library(RColorBrewer)

dir.create(here(paste0("plots/NMF/")))
dir.create(here(paste0("results/NMF/")))

dimensionalities <- as.character(dimensionalities)
  go_res <- map(dimensionalities, function(dimen){
    
  
  gene_weights <- nmf_list[[dimen]][["P"]]
  #Depending on how weights were saved, make sure ensembl IDS are in column titled with gene_id
  
  patterns <- colnames(gene_weights)

  
  map(patterns, function(pt){
    if(!dir.exists(here(paste0("plots/NMF/dim",dimen,"/")))){
      dir.create(here(paste0("plots/NMF/dim",dimen,"/")))
    }
  })
  
  map(patterns, function(pt){
    if(!dir.exists(here(paste0("results/NMF/dim",dimen,"/")))){
      dir.create(here(paste0("results/NMF/dim",dimen,"/")))
    }
  })
  
  gsea_results <- map(patterns, function(pt){
  
    print(pt)
  
    #top n genes (for over representation analysis)
    # genes <- pheno_gene_list[[trt]] %>% deframe()
  
    #all genes (for gsea)
    genes <-  gene_weights[,pt,drop = F] %>% as.data.frame() %>% rownames_to_column() %>% deframe %>% sort(., decreasing = T)
  
    print("Gene ranks prepped... Running GSEA")
    #gene set enrichment analysis
    res <- gseGO(geneList     = genes,
                  OrgDb        = org.Mm.eg.db,
                  ont          = "ALL",
                  keyType      = "ENSEMBL",
                  minGSSize    = 10,
                  maxGSSize    = 500,
                  pvalueCutoff = 1,
                  verbose      = TRUE)
  
  
    pdf(here(paste0("plots/NMF/dim",dimen,"/gsea_", pt,".pdf")), width = 20, height = 20)
    print(enrichplot::dotplot(res, showCategory=15, split="ONTOLOGY") + facet_grid(ONTOLOGY~., scales = "free")  +
      ggtitle(paste0("Subset of GO enriched terms for ", pt)))
  
    summary <- as.data.frame(res) %>%
      dplyr::filter(ONTOLOGY == "BP") %>%
      dplyr::select(ONTOLOGY, Description, p.adjust, qvalues, setSize)
  
    colnames(summary)[colnames(summary) == "Description"] <- paste0("Description - GO Terms for ", pt)
  
  
    sub1 <- summary[1:55,]
    sub2 <- summary[56:110,]
    grid.newpage()
    g1 <- gridExtra::grid.table(sub1,theme=ttheme_minimal(base_size = 8))
    grid.newpage()
    print("test")
    g2 <- gridExtra::grid.table(sub2,theme=ttheme_minimal(base_size = 8))
  
  
    dev.off()
  
    write_tsv(summary,here(paste0("results/NMF/dim",dimen,"/gsea_", pt,".tsv")))
    
    return(res)
    
    
  })
})

```


```{r, eval = T}

library(clusterProfiler)
library(org.Mm.eg.db)
library(DOSE)
library(grid)
library(gridExtra)
library(biomaRt)
library(RColorBrewer)

dir.create(here(paste0("plots/diff_exp/GSEA/")))
dir.create(here(paste0("results/diff_exp_GSEA/")))

name <- "age_17mo_vs_P30"
comp_res <- results(dds,name = name) %>%
    as.data.frame() %>%
    rownames_to_column(var = "ensemblgene_id") %>%
    left_join(., gene_ids, by= "ensemblgene_id") %>%
    relocate(external_gene_name) %>%
    arrange(desc(log2FoldChange))

#all genes (for gsea)
genes <- comp_res %>% dplyr::select(ensemblgene_id, log2FoldChange) %>% deframe() 
    
  
    print("Gene ranks prepped... Running GSEA")
    #gene set enrichment analysis
    res <- gseGO(geneList     = genes,
                  OrgDb        = org.Mm.eg.db,
                  ont          = "ALL",
                  keyType      = "ENSEMBL",
                  minGSSize    = 10,
                  maxGSSize    = 500,
                  pvalueCutoff = 1,
                  verbose      = TRUE)
  
  
    pdf(here(paste0("plots/diff_exp/GSEA/gsea_", name,".pdf")), width = 20, height = 20)
    print(enrichplot::dotplot(res, showCategory=15, split="ONTOLOGY") + facet_grid(ONTOLOGY~., scales = "free")  +
      ggtitle(paste0("Subset of GO enriched terms for ", pt)))
  
    summary <- as.data.frame(res) %>%
      dplyr::filter(ONTOLOGY == "BP") %>%
      dplyr::select(ONTOLOGY, Description, p.adjust, qvalues, setSize)
  
    colnames(summary)[colnames(summary) == "Description"] <- paste0("Description - GO Terms for ", pt)
  
  
    sub1 <- summary[1:55,]
    sub2 <- summary[56:110,]
    grid.newpage()
    g1 <- gridExtra::grid.table(sub1,theme=ttheme_minimal(base_size = 8))
    grid.newpage()
    print("test")
    g2 <- gridExtra::grid.table(sub2,theme=ttheme_minimal(base_size = 8))
  
  
    dev.off()
  
    write_tsv(summary,here(paste0("results/diff_exp/GSEA/gsea_", name,".tsv")))
    
    return(res)
    
    
  })
})

```